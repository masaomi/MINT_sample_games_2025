<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genome Assembly Puzzle üß©</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --bg-color: #ecf0f1;
            --text-color: #2c3e50;
            --piece-bg: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--secondary-color);
            opacity: 0.8;
        }

        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s, background-color 0.2s;
            font-weight: bold;
            color: white;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-start {
            background-color: var(--accent-color);
            box-shadow: 0 4px 0 #2980b9;
            min-width: 120px;
        }

        .btn-reset {
            background-color: #e74c3c;
            box-shadow: 0 4px 0 #c0392b;
        }

        /* Difficulty Buttons */
        .difficulty-selector {
            display: flex;
            background: white;
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .ploidy-selector {
            display: flex;
            background: white;
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-right: 10px;
        }

        .btn-diff, .btn-ploidy {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 600;
            color: var(--secondary-color);
            border-radius: 5px;
            transition: all 0.2s;
        }

        .btn-diff:hover, .btn-ploidy:hover {
            background-color: #f0f2f5;
        }

        .btn-diff.active, .btn-ploidy.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .timer-display {
            font-size: 2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: var(--primary-color);
            background: white;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid var(--primary-color);
            min-width: 150px;
            text-align: center;
        }

        .puzzle-container {
            background: #bdc3c7;
            /* border-radius: 10px; Remove radius to look more like a desk? keep it for container feel */
            border-radius: 10px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
            position: relative; /* For absolute positioning of pieces */
            width: 100%;
            height: 600px; /* Fixed height for the workspace */
            overflow: hidden; /* Keep pieces inside */
            margin-bottom: 30px;
            user-select: none; /* Prevent selection while dragging */
        }

        /* Remove row styles */
        .puzzle-row {
            display: none; 
        }

        .puzzle-piece {
            background: var(--piece-bg);
            border: 2px solid var(--secondary-color);
            border-radius: 5px;
            cursor: grab;
            user-select: none;
            /* position: absolute; Added via JS, but good to know */
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            min-width: 80px;
            height: 60px;
            z-index: 10;
            transition: box-shadow 0.2s, transform 0.1s; /* Remove transform transition for smooth drag */
        }

        .puzzle-piece.dragging {
            cursor: grabbing;
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
            z-index: 1000; /* Bring to front */
            opacity: 0.9;
        }
        
        /* Remove old connection styles, we will handle connections differently or keep visual cues */
        .puzzle-piece.connected-right {
            border-right: none; /* Remove border to look seamless */
        }
        
        .puzzle-piece.connected-left {
            border-left: none;
        }
        
        /* Add a connector visual between pieces? */
        .puzzle-piece::after {
            /* ... old style ... */
            display: none;
        }

        /* Connected group styling */
        .puzzle-piece[data-group] {
            /* maybe highlight? */
            transition: box-shadow 0.2s;
        }

        .seq-overlap {
            color: #d35400;
            background-color: #fce5cd;
            font-weight: 900;
            padding: 2px 4px;
            border-radius: 4px;
            border-bottom: 2px solid #e67e22;
        }
        
        .seq-core {
            color: var(--text-color);
            font-weight: 500;
            padding: 0 2px;
        }

        .ranking-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
        }

        .ranking-title {
            text-align: center;
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px;
        }

        .ranking-table {
            width: 100%;
            border-collapse: collapse;
        }

        .ranking-table th, .ranking-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .ranking-table th {
            background-color: #f8f9fa;
            font-weight: bold;
            color: var(--secondary-color);
        }

        .ranking-table tr:last-child td {
            border-bottom: none;
        }
        
        .empty-rank {
            text-align: center;
            color: #95a5a6;
            padding: 20px;
            font-style: italic;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal h2 {
            color: var(--success-color);
            font-size: 2rem;
            margin-bottom: 15px;
        }

        .modal-score {
            font-size: 3rem;
            font-weight: bold;
            color: var(--primary-color);
            margin: 20px 0;
        }
        
        .input-group {
            margin: 20px 0;
        }

        .input-group input {
            padding: 10px;
            font-size: 1.1rem;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 80%;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .puzzle-piece {
                font-size: 0.6rem;
            }
            h1 {
                font-size: 1.8rem;
            }
        }
    </style>
    <!-- Firebase SDK (for cloud scores on Vercel) -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
</head>
<body>

    <header>
        <h1>Genome Assembly Puzzle üß©</h1>
        <p class="subtitle">Reconstruct the genome sequence by ordering the fragments!</p>
    </header>

    <div class="game-controls">
        <div class="control-row">
            <div class="ploidy-selector" id="ploidySelector">
                <button class="btn-ploidy active" data-ploidy="1">Haploid (1)</button>
                <button class="btn-ploidy" data-ploidy="2">Polyploid (2)</button>
                </div>
            <div class="difficulty-selector" id="difficultySelector">
                <button class="btn-diff" data-level="easy">Easy</button>
                <button class="btn-diff active" data-level="medium">Medium</button>
                <button class="btn-diff" data-level="hard">Hard</button>
                <button class="btn-diff" data-level="expert">Expert</button>
                    </div>
                    </div>
        <div class="control-row">
            <div class="timer-display" id="timer">00:00.000</div>
            <button id="startBtn" class="btn btn-start">Start Game</button>
            <button id="stopBtn" class="btn btn-reset" style="display:none;">Stop</button>
                </div>
        <!-- <button id="resetBtn" class="btn btn-reset">Reset</button> -->
                </div>

    <div class="puzzle-container" id="puzzleBoard">
        <!-- Pieces will be generated here -->
        <div style="text-align: center; color: #7f8c8d; width: 100%; padding: 40px;">
            <p style="font-size: 1.2em; margin-bottom: 10px;"><strong>How to Play:</strong></p>
            <p>1. Click "Start Game" to begin.</p>
            <p>2. <strong>Drag and Drop</strong> pieces to reorder them.</p>
            <p>3. <strong>Match the orange text!</strong> The end of one piece matches the start of the next.</p>
            <p>4. A üîó icon will appear when pieces are correctly connected.</p>
                </div>
            </div>

    <div class="ranking-container">
        <h2 class="ranking-title" id="rankingTitle">üèÜ Local Rankings</h2>
        <p id="rankingMode" style="text-align: center; font-size: 0.9em; color: #7f8c8d; margin-bottom: 10px;"></p>
        <table class="ranking-table" id="rankingTable">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Name</th>
                    <th>Time</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody id="rankingBody">
                <!-- Ranking rows -->
            </tbody>
        </table>
                </div>

    <!-- Victory Modal -->
    <div class="modal" id="victoryModal">
        <div class="modal-content">
            <h2>üéâ Assembly Complete!</h2>
            <p>You successfully reconstructed the genome!</p>
            <div class="modal-score" id="finalTime">00:00.000</div>
            
            <div class="input-group" id="nameInputGroup">
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                </div>

            <button id="saveScoreBtn" class="btn btn-start">Save Score & Play Again</button>
            <button id="closeModalBtn" class="btn btn-reset" style="margin-top: 10px;">Close</button>
        </div>
    </div>

    <script>
        // ============================================
        // Firebase Configuration
        // ============================================
        // IMPORTANT: Replace these values with your Firebase project settings
        // Get these from: Firebase Console > Project Settings > General > Your apps > Web app
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyDNjZr7bJFiq50A2LNhp5m3aqBUJX1Dzdk",
            authDomain: "mint-sample-games-2025.firebaseapp.com",
            databaseURL: "https://mint-sample-games-2025-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "mint-sample-games-2025",
            storageBucket: "mint-sample-games-2025.firebasestorage.app",
            messagingSenderId: "730624731504",
            appId: "1:730624731504:web:5cad65bf3c91bcf2dd47b5"
        };

        // Cloud Storage Manager
        class CloudStorage {
            constructor() {
                this.enabled = false;
                this.db = null;
                this.init();
            }

            // Check if we should enable cloud features
            isCloudEnvironment() {
                const hostname = window.location.hostname;
                // Enable cloud on Vercel deployments or custom domains (not localhost/file/github.io)
                const isVercel = hostname.includes('.vercel.app');
                const isCustomDomain = !hostname.includes('localhost') && 
                                       !hostname.includes('127.0.0.1') &&
                                       !hostname.includes('.github.io') &&
                                       hostname !== '' && // file:// protocol
                                       !hostname.includes('file:');
                
                // Check if Firebase config is properly set
                const isConfigured = FIREBASE_CONFIG.apiKey !== "YOUR_API_KEY" &&
                                     FIREBASE_CONFIG.projectId !== "YOUR_PROJECT_ID";
                
                return (isVercel || isCustomDomain) && isConfigured;
            }

            init() {
                if (!this.isCloudEnvironment()) {
                    console.log('‚òÅÔ∏è Cloud storage disabled (local environment or unconfigured)');
                    this.enabled = false;
                    return;
                }

                try {
                    firebase.initializeApp(FIREBASE_CONFIG);
                    this.db = firebase.database();
                    this.enabled = true;
                    console.log('‚òÅÔ∏è Cloud storage enabled (Firebase)');
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    this.enabled = false;
                }
            }

            async saveScore(scoreData) {
                if (!this.enabled || !this.db) return false;
                
                try {
                    await this.db.ref('scores').push({
                        ...scoreData,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    return true;
                } catch (error) {
                    console.error('Cloud save failed:', error);
                    return false;
                }
            }

            loadScores(difficulty, ploidy, callback) {
                if (!this.enabled || !this.db) {
                    callback([]);
                    return;
                }

                // Load all scores and filter client-side (Firebase free tier has limited querying)
                this.db.ref('scores')
                    .orderByChild('time')
                    .limitToFirst(500)
                    .on('value', snapshot => {
                        const data = snapshot.val();
                        if (!data) {
                            callback([]);
                            return;
                        }

                        // Convert to array and filter
                        const scores = Object.values(data)
                            .filter(s => s.difficulty === difficulty && 
                                        (s.ploidy === ploidy || (ploidy === 1 && !s.ploidy)))
                            .sort((a, b) => a.time - b.time)
                            .slice(0, 10);

                        callback(scores);
                    }, error => {
                        console.error('Cloud load failed:', error);
                        callback([]);
                    });
            }

            // Detach listener when not needed
            detachListener() {
                if (this.db) {
                    this.db.ref('scores').off();
                }
            }
        }

        // Initialize cloud storage
        const cloudStorage = new CloudStorage();

        // Game Configuration
        const CONFIG = {
            easy: { pieces: 5, rows: 1, length: 20, overlap: 2 },
            medium: { pieces: 10, rows: 2, length: 40, overlap: 3 },
            hard: { pieces: 20, rows: 4, length: 80, overlap: 3 },
            expert: { pieces: 50, rows: 5, length: 200, overlap: 4 }
        };

        class Game {
            constructor() {
                this.pieces = [];
                this.isPlaying = false;
                this.startTime = 0;
                this.timerInterval = null;
                this.currentDifficulty = 'medium';
                this.currentPloidy = 1; // 1 = Haploid, 2 = Diploid (Polyploid)
                
                // For drag logic
                this.draggedPiece = null;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.isDragging = false;

                // DOM Elements
                this.board = document.getElementById('puzzleBoard');
                this.timerDisplay = document.getElementById('timer');
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.difficultySelector = document.getElementById('difficultySelector');
                this.difficultyButtons = this.difficultySelector.querySelectorAll('.btn-diff');
                this.ploidySelector = document.getElementById('ploidySelector');
                this.ploidyButtons = this.ploidySelector.querySelectorAll('.btn-ploidy');
                this.rankingBody = document.getElementById('rankingBody');
                this.rankingTitle = document.getElementById('rankingTitle');
                this.rankingMode = document.getElementById('rankingMode');
                this.victoryModal = document.getElementById('victoryModal');
                this.finalTimeDisplay = document.getElementById('finalTime');
                this.saveScoreBtn = document.getElementById('saveScoreBtn');
                this.playerNameInput = document.getElementById('playerName');
                this.closeModalBtn = document.getElementById('closeModalBtn');

                // Bind events
                this.startBtn.addEventListener('click', () => this.start());
                this.stopBtn.addEventListener('click', () => this.stop());
                
                // Board events for drag
                this.board.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Touch events
                this.board.addEventListener('touchstart', (e) => this.onTouchStart(e), {passive: false});
                window.addEventListener('touchmove', (e) => this.onTouchMove(e), {passive: false});
                window.addEventListener('touchend', (e) => this.onTouchEnd(e));

                // Difficulty buttons logic
                this.difficultyButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (this.isPlaying) return; 
                        this.setDifficulty(btn.dataset.level);
                    });
                });

                // Ploidy buttons logic
                this.ploidyButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (this.isPlaying) return;
                        this.setPloidy(parseInt(btn.dataset.ploidy));
                    });
                });

                this.saveScoreBtn.addEventListener('click', () => this.saveScore());
                this.closeModalBtn.addEventListener('click', () => this.victoryModal.classList.remove('show'));

                // Load rankings
                this.updateRankingDisplay();
            }
            
            setDifficulty(level) {
                this.currentDifficulty = level;
                this.difficultyButtons.forEach(btn => {
                    if (btn.dataset.level === level) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                this.updateRankingDisplay(); // Update table immediately
            }

            setPloidy(ploidy) {
                this.currentPloidy = ploidy;
                this.ploidyButtons.forEach(btn => {
                    if (parseInt(btn.dataset.ploidy) === ploidy) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                this.updateRankingDisplay(); // Update table immediately
            }

            stop() {
                this.isPlaying = false;
                this.stopTimer();
                this.startBtn.style.display = 'inline-block';
                this.stopBtn.style.display = 'none';
                this.startBtn.textContent = 'Start Game';
                
                // Clear board
                this.pieces = [];
                this.renderBoard();
                
                // Re-enable controls
                this.toggleControls(true);
                
                // Reset Timer Display
                this.timerDisplay.textContent = '00:00.000';
            }
            
            toggleControls(enable) {
                // Enable/Disable Difficulty Buttons
                this.difficultyButtons.forEach(btn => {
                    btn.style.pointerEvents = enable ? 'auto' : 'none';
                    btn.style.opacity = enable ? '1' : '0.6';
                });
                
                // Enable/Disable Ploidy Buttons
                this.ploidyButtons.forEach(btn => {
                    btn.style.pointerEvents = enable ? 'auto' : 'none';
                    btn.style.opacity = enable ? '1' : '0.6';
                });
            }

            generateSequence(length) {
            const bases = ['A', 'T', 'G', 'C'];
                let seq = '';
            for (let i = 0; i < length; i++) {
                    seq += bases[Math.floor(Math.random() * bases.length)];
                }
                return seq;
            }

            start() {
                if (this.isPlaying) {
                    this.stop(); 
                }
                
                const config = CONFIG[this.currentDifficulty];
                this.isPlaying = true;
                this.startBtn.style.display = 'none';
                this.stopBtn.style.display = 'inline-block';
                
                this.pieces = [];
                
                // Disable controls while playing
                this.toggleControls(false);
                
                try {
                    // Generate full sequence
                    const uniquePerPiece = Math.floor(config.length / config.pieces);
                    const totalLength = (uniquePerPiece * config.pieces) + config.overlap;
                    
                    // Generate base sequence
                    const baseSequence = this.generateSequence(totalLength);

                    // Board dimensions
                    const boardRect = this.board.getBoundingClientRect();
                    // Ensure valid dimensions
                    const boardW = (boardRect.width > 100) ? boardRect.width : 800;
                    const boardH = (boardRect.height > 100) ? boardRect.height : 600;
                    
                    for (let h = 0; h < this.currentPloidy; h++) {
                        let homeologSequence = baseSequence;
                        
                        if (h > 0) {
                            // Introduce variations for subsequent homeologs
                            homeologSequence = this.introduceVariations(baseSequence, 5 + config.pieces);
                        }

                        this.generatePiecesForHomeolog(homeologSequence, h, config, uniquePerPiece, boardW, boardH);
                    }

                    this.renderBoard();
                    this.startTimer();
                } catch (e) {
                    console.error("Game start error:", e);
                    this.stop();
                }
            }

            introduceVariations(sequence, count) {
                const bases = ['A', 'T', 'G', 'C'];
                let seqArr = sequence.split('');
                for (let i = 0; i < count; i++) {
                    const pos = Math.floor(Math.random() * seqArr.length);
                    const current = seqArr[pos];
                    let next = bases[Math.floor(Math.random() * bases.length)];
                    while (next === current) {
                        next = bases[Math.floor(Math.random() * bases.length)];
                    }
                    seqArr[pos] = next;
                }
                return seqArr.join('');
            }

            generatePiecesForHomeolog(sequence, homeologIndex, config, uniquePerPiece, boardW, boardH) {
                const fullSequence = sequence;
                
                for (let i = 0; i < config.pieces; i++) {
                    const start = i * uniquePerPiece;
                    let end = start + uniquePerPiece + config.overlap;
                    if (i === config.pieces - 1) end = fullSequence.length;
                    if (end > fullSequence.length) end = fullSequence.length;

                    const chunk = fullSequence.substring(start, end);
                    
                    const overlapStart = (i > 0) ? chunk.substring(0, config.overlap) : '';
                    const overlapEnd = (i < config.pieces - 1) ? chunk.substring(chunk.length - config.overlap) : '';
                    
                    let core = chunk;
                    if (i > 0) core = core.substring(config.overlap);
                    if (i < config.pieces - 1) core = core.substring(0, core.length - config.overlap);

                    // Color based on homeolog index to help distinguish slightly?
                    // Or purely position based?
                    // Let's give a slight tint difference
                    // Base hue 0-270. 
                    // Homeolog 1: Normal
                    // Homeolog 2: Shift hue by 180? Or use different saturation?
                    
                    let hue = Math.floor((i / (config.pieces - 1)) * 270);
                    
                    // Tint for homeologs
                    // H1: Normal rainbow
                    // H2: +30 offset? Or maybe different lightness
                    if (homeologIndex === 1) {
                        hue = (hue + 180) % 360; // Distinct color set
                    }

                    const color = `hsl(${hue}, ${homeologIndex === 0 ? '70%' : '60%'}, ${homeologIndex === 0 ? '60%' : '50%'})`;

                    // Random Position
                    const randX = Math.random() * (boardW - 150);
                    const randY = Math.random() * (boardH - 100);
                    
                    // Unique ID across all pieces: (homeologIndex * 1000) + i
                    const globalId = (homeologIndex * 1000) + i;
                    const groupId = globalId; // Initially distinct

                    this.pieces.push({
                        id: i, // Relative ID in sequence
                        globalId: globalId,
                        homeolog: homeologIndex,
                        fullText: chunk,
                        overlapStart: overlapStart,
                        overlapEnd: overlapEnd,
                        core: core,
                        color: color,
                        x: randX,
                        y: randY,
                        width: 0,
                        height: 0,
                        groupId: groupId,
                        element: null
                    });
                }
            }

            shuffle(array) {
                // No longer needed for absolute positioning logic, we just randomize coords
            }

            renderBoard() {
                this.board.innerHTML = '';
                
                // Just loop through pieces and create them
                this.pieces.forEach((piece, index) => {
                    const el = document.createElement('div');
                    el.className = 'puzzle-piece';
                    el.dataset.index = index; 
                    
                    // Set initial position
                    el.style.left = piece.x + 'px';
                    el.style.top = piece.y + 'px';

                    // Visual styling
                    el.style.width = 'auto';
                    el.style.minWidth = '60px';
                    el.style.height = '60px'; // slightly smaller for better fit
                    
                    const hint = document.createElement('div');
                    hint.className = 'piece-hint';
                    hint.style.backgroundColor = piece.color;
                    el.appendChild(hint);

                    const content = document.createElement('div');
                    content.className = 'piece-content';
                    
                    let html = '';
                    if (piece.overlapStart) html += `<span class="seq-overlap">${piece.overlapStart}</span>`;
                    html += `<span class="seq-core">${piece.core}</span>`;
                    if (piece.overlapEnd) html += `<span class="seq-overlap">${piece.overlapEnd}</span>`;
                    
                    content.innerHTML = html;
                    el.appendChild(content);

                    this.board.appendChild(el);
                    piece.element = el;

                    // Get dimensions after append
                    const rect = el.getBoundingClientRect();
                    piece.width = rect.width;
                    piece.height = rect.height;
                });
            }

            // --- Mouse / Touch Handling ---

            onMouseDown(e) {
                if (!this.isPlaying) return;
                const target = e.target.closest('.puzzle-piece');
                if (!target) return;

                    e.preventDefault();
                const index = parseInt(target.dataset.index);
                this.startDrag(index, e.clientX, e.clientY);
            }

            onTouchStart(e) {
                if (!this.isPlaying) return;
                const target = e.target.closest('.puzzle-piece');
                if (!target) return;

                // e.preventDefault(); // Don't prevent default here to allow scrolling if needed? Actually we want to prevent scroll on pieces
                if (e.touches.length === 1) {
                    e.preventDefault();
                    const index = parseInt(target.dataset.index);
                    this.startDrag(index, e.touches[0].clientX, e.touches[0].clientY);
                }
            }

            startDrag(index, clientX, clientY) {
                this.draggedPiece = this.pieces[index];
                this.isDragging = true;
                
                // Calculate offset from the piece's top-left
                const rect = this.draggedPiece.element.getBoundingClientRect();
                this.dragOffsetX = clientX - rect.left;
                this.dragOffsetY = clientY - rect.top;

                // Bring group to front
                this.bringGroupToFront(this.draggedPiece.groupId);
                this.draggedPiece.element.classList.add('dragging');
            }

            onMouseMove(e) {
                if (!this.isDragging || !this.draggedPiece) return;
                    e.preventDefault();
                this.updateDrag(e.clientX, e.clientY);
                    }

            onTouchMove(e) {
                if (!this.isDragging || !this.draggedPiece) return;
                    e.preventDefault();
                this.updateDrag(e.touches[0].clientX, e.touches[0].clientY);
            }

            updateDrag(clientX, clientY) {
                // Calculate new position for the dragged piece
                // Relative to board container
                const boardRect = this.board.getBoundingClientRect();
                let newX = clientX - boardRect.left - this.dragOffsetX;
                let newY = clientY - boardRect.top - this.dragOffsetY;

                // Constrain to board
                // newX = Math.max(0, Math.min(newX, boardRect.width - this.draggedPiece.width));
                // newY = Math.max(0, Math.min(newY, boardRect.height - this.draggedPiece.height));

                // Move the entire group
                const dx = newX - this.draggedPiece.x;
                const dy = newY - this.draggedPiece.y;

                this.moveGroup(this.draggedPiece.groupId, dx, dy);
            }

            moveGroup(groupId, dx, dy) {
                this.pieces.forEach(p => {
                    if (p.groupId === groupId) {
                        p.x += dx;
                        p.y += dy;
                        p.element.style.left = p.x + 'px';
                        p.element.style.top = p.y + 'px';
                    }
                });
            }

            onMouseUp(e) {
                if (this.isDragging) {
                    this.endDrag();
                }
            }

            onTouchEnd(e) {
                if (this.isDragging) {
                    this.endDrag();
                }
            }

            endDrag() {
                if (!this.draggedPiece) return;
                
                this.draggedPiece.element.classList.remove('dragging');
                
                // Check for snapping
                this.checkSnapping(this.draggedPiece.groupId);
                
                this.isDragging = false;
                this.draggedPiece = null;
                
                this.checkWin();
            }

            bringGroupToFront(groupId) {
                // Find max z-index
                // Simple approach: just increment a global z-index or set high
                this.pieces.forEach(p => {
                    if (p.groupId === groupId) {
                        p.element.style.zIndex = 100;
                    } else {
                        p.element.style.zIndex = 10;
                    }
                });
            }

            checkSnapping(activeGroupId) {
                const SNAP_DISTANCE = 30; // px
                
                // Get all pieces in the active group
                const activePieces = this.pieces.filter(p => p.groupId === activeGroupId);
                
                let snapped = false;

                // Try to snap any piece in the active group to any piece NOT in the group
                for (const activeP of activePieces) {
                    // Look for Neighbors: ID-1 (Left) or ID+1 (Right)
                    // MUST also match HOMEOLOG index!
                    
                    // Check Left Neighbor (activeP.id - 1)
                    if (activeP.id > 0) {
                        // Find the piece with id - 1 AND same homeolog
                        const leftNeighbor = this.pieces.find(p => p.homeolog === activeP.homeolog && p.id === activeP.id - 1);
                        
                        if (leftNeighbor && leftNeighbor.groupId !== activeGroupId) {
                            // Check distance
                            const targetX = leftNeighbor.x + leftNeighbor.width - 10;
                            const targetY = leftNeighbor.y;
                            
                            const dist = Math.hypot(activeP.x - targetX, activeP.y - targetY);
                            
                            if (dist < SNAP_DISTANCE) {
                                const dx = targetX - activeP.x;
                                const dy = targetY - activeP.y;
                                this.moveGroup(activeGroupId, dx, dy);
                                this.mergeGroups(leftNeighbor.groupId, activeGroupId);
                                snapped = true;
                                break;
                            }
                        }
                    }
                    
                    // Check Right Neighbor (activeP.id + 1)
                    // Find piece with id + 1 AND same homeolog
                    // Max ID is config.pieces - 1
                    // Since config isn't stored in class directly, check if neighbor exists
                    const rightNeighbor = this.pieces.find(p => p.homeolog === activeP.homeolog && p.id === activeP.id + 1);
                    
                    if (rightNeighbor && rightNeighbor.groupId !== activeGroupId) {
                         const targetX = rightNeighbor.x - activeP.width + 10;
                         const targetY = rightNeighbor.y;
                         
                         const dist = Math.hypot(activeP.x - targetX, activeP.y - targetY);
                         
                         if (dist < SNAP_DISTANCE) {
                             const dx = targetX - activeP.x;
                             const dy = targetY - activeP.y;
                             this.moveGroup(activeGroupId, dx, dy);
                             this.mergeGroups(rightNeighbor.groupId, activeGroupId);
                             snapped = true;
                             break;
                         }
                    }
                }
                
                // Play sound or visual effect if snapped?
                if (snapped) {
                    // highlight?
                }
            }

            mergeGroups(targetGroupId, sourceGroupId) {
                this.pieces.forEach(p => {
                    if (p.groupId === sourceGroupId) {
                        p.groupId = targetGroupId;
                        
                        // Add flash effect
                        p.element.style.transition = 'none';
                        p.element.style.borderColor = '#2ecc71';
                setTimeout(() => {
                            p.element.style.transition = 'box-shadow 0.2s';
                            p.element.style.borderColor = ''; // Reset to css default
                        }, 300);
                    }
                });
            }

            checkWin() {
                // Win condition:
                // For each homeolog, all pieces must be in ONE group.
                // And that group should contain ONLY pieces from that homeolog? 
                // Actually, if we enforce correct connection (same homeolog, consecutive ID), 
                // then a "completed" state is just when we have exactly `currentPloidy` groups remaining,
                // and each group consists of all pieces for one homeolog.
                
                // Let's count groups.
                const groups = new Set(this.pieces.map(p => p.groupId));
                
                if (groups.size === this.currentPloidy) {
                    // Potential win. Check if each group is complete.
                    const config = CONFIG[this.currentDifficulty];
                    const piecesPerHomeolog = config.pieces;
                    
                    // Check sizes of groups
                    let allComplete = true;
                    
                    // Map group ID to count
                    const groupCounts = {};
                    this.pieces.forEach(p => {
                        groupCounts[p.groupId] = (groupCounts[p.groupId] || 0) + 1;
                    });
                    
                    for (let gid in groupCounts) {
                        if (groupCounts[gid] !== piecesPerHomeolog) {
                            allComplete = false;
                            break;
                        }
                    }
                    
                    if (allComplete) {
                        this.gameWin();
                    }
                }
            }

            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    this.updateTimerDisplay();
                }, 10);
            }

            stopTimer() {
                clearInterval(this.timerInterval);
            }

            updateTimerDisplay() {
                const now = Date.now();
                const diff = now - this.startTime;
                this.timerDisplay.textContent = this.formatTime(diff);
            }

            formatTime(ms) {
                const minutes = Math.floor(ms / 60000);
                const seconds = Math.floor((ms % 60000) / 1000);
                const milliseconds = ms % 1000;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }

            gameWin() {
                this.isPlaying = false;
                this.stopTimer();
                const finalTime = Date.now() - this.startTime;
                this.currentFinalTime = finalTime; // Store for saving
                
                // Show modal
                this.finalTimeDisplay.textContent = this.formatTime(finalTime);
                this.victoryModal.classList.add('show');
                
                // Focus input
                setTimeout(() => this.playerNameInput.focus(), 100);
            }

            async saveScore() {
                const name = this.playerNameInput.value.trim() || 'Anonymous';
                const scoreData = {
                    name: name,
                    time: this.currentFinalTime,
                    formattedTime: this.formatTime(this.currentFinalTime),
                    difficulty: this.currentDifficulty,
                    ploidy: this.currentPloidy,
                    date: new Date().toLocaleDateString()
                };

                // Always save to localStorage (as backup / offline)
                this.saveToLocalStorage(scoreData);

                // Try to save to cloud if enabled
                if (cloudStorage.enabled) {
                    const cloudSaved = await cloudStorage.saveScore(scoreData);
                    if (cloudSaved) {
                        console.log('‚úÖ Score saved to cloud');
                    } else {
                        console.log('‚ö†Ô∏è Cloud save failed, score saved locally only');
                    }
                }
                
                this.updateRankingDisplay();
                this.victoryModal.classList.remove('show');
                this.playerNameInput.value = '';
            }

            saveToLocalStorage(scoreData) {
                let scores = JSON.parse(localStorage.getItem('genomePuzzleScores') || '[]');
                scores.push(scoreData);
                scores.sort((a, b) => a.time - b.time);
                
                // Limit to 100 scores to prevent storage overflow
                if (scores.length > 100) scores = scores.slice(0, 100);

                localStorage.setItem('genomePuzzleScores', JSON.stringify(scores));
            }

            updateRankingDisplay() {
                // Update title and mode indicator based on cloud status
                if (cloudStorage.enabled) {
                    this.rankingTitle.textContent = 'üåê Global Rankings';
                    this.rankingMode.textContent = '‚òÅÔ∏è Cloud mode - Scores shared with all players';
                    this.rankingMode.style.color = '#27ae60';
                    
                    // Load from cloud
                    cloudStorage.loadScores(this.currentDifficulty, this.currentPloidy, (scores) => {
                        this.renderScores(scores);
                    });
                } else {
                    this.rankingTitle.textContent = 'üèÜ Local Rankings';
                    this.rankingMode.textContent = 'üíæ Local mode - Scores saved on this device only';
                    this.rankingMode.style.color = '#7f8c8d';
                    
                    // Load from localStorage
                    const localScores = this.getLocalScores();
                    this.renderScores(localScores);
                }
            }

            getLocalScores() {
                const scores = JSON.parse(localStorage.getItem('genomePuzzleScores') || '[]');
                
                // Filter scores based on current difficulty AND ploidy
                const filteredScores = scores.filter(s => 
                    s.difficulty === this.currentDifficulty && 
                    (s.ploidy === this.currentPloidy || (this.currentPloidy === 1 && !s.ploidy))
                );

                // Sort and take top 10
                filteredScores.sort((a, b) => a.time - b.time);
                return filteredScores.slice(0, 10);
            }

            renderScores(topScores) {
                this.rankingBody.innerHTML = '';

                if (!topScores || topScores.length === 0) {
                    this.rankingBody.innerHTML = '<tr><td colspan="4" class="empty-rank">No records for this mode. Be the first!</td></tr>';
                    return;
                }

                topScores.forEach((score, index) => {
                    const tr = document.createElement('tr');
                    const ploidyLabel = (score.ploidy === 2) ? 'Polyploid' : 'Haploid';
                    tr.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${this.escapeHtml(score.name)} <span style="font-size:0.8em; color:#7f8c8d">(${ploidyLabel})</span></td>
                        <td>${score.formattedTime}</td>
                        <td>${score.date}</td>
                    `;
                    this.rankingBody.appendChild(tr);
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Initialize game
        window.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
        });

    </script>
</body>
</html>
